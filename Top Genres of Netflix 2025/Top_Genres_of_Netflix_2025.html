<!DOCTYPE html>
<html>
<head>
<title>report_nf.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="top-genres-of-netflix-shows-2025">Top Genres of Netflix Shows 2025</h1>
<h2 id="report-and-conclusion">Report and Conclusion</h2>
<h3 id="objective">Objective:</h3>
<p>The goal of this project was to explore Netflix’s 2025 shows dataset and identify the top-performing genres based on multiple metrics:</p>
<ul>
<li>Rating</li>
<li>Popularity</li>
<li>Average Vote</li>
</ul>
<h3 id="methodology">Methodology:</h3>
<h4 id="data-collection">Data Collection:</h4>
<p>Data was collected by Kaggle.</p>
<h4 id="data-cleaning-and-preprocessing">Data Cleaning and Preprocessing:</h4>
<ol>
<li>
<p>Handled Missing Values in genres and country</p>
<p>Before Handling Missing Values:
<img src="HEATMAP_before.png" alt="heatmap_BEFORE"></p>
<p>The Heatmap is showing that genres and country had the missing values</p>
<p>After Handling Missing Values:
<img src="HEATMAP_AFTER.png" alt="heatmap_AFTER"></p>
<h4 id="country">Country:</h4>
<p>I imputed the country column using a dictionary of languages, and language column that is present in data.</p>
</li>
</ol>
<pre class="hljs"><code><div># Example dictionary (you can expand it based on your dataset)
language_country_map = {
    'English': 'United States',
    'Hindi': 'India',
    'Spanish': 'Spain',  
    'French': 'France',
    'Japanese': 'Japan',
    'Korean': 'South Korea',
    'Mandarin': 'China',
    'German': 'Germany',
    'Italian': 'Italy',
    'Turkish': 'Turkey'
}
</div></code></pre>
<p>then filled missing entries with this dictionary</p>
<pre class="hljs"><code><div>import numpy as np

# Fill missing 'country' using 'language' column

df['country'] = np.where(
    df['country'].isna(), 
    df['language'].map(language_country_map),  # map language to country
    df['country']  # keep existing country
)

# For any rows where country is still missing (language not in map), fill with &quot;Unknown&quot;

df['country'] = df['country'].fillna(&quot;Unknown&quot;)

</div></code></pre>
<h4 id="genres">genres:</h4>
<p>I imputed genres by the help of title.</p>
<p>First i defined a dictionary of keywords related to genres</p>
<pre class="hljs"><code><div># Dictionary of keywords and their corresponding genres

keyword_genre_map = {
    'love': 'Romance',
    'romantic': 'Romance',
    'crime': 'Crime',
    'detective': 'Crime',
    'murder': 'Crime',
    'war': 'War',
    'battle': 'War',
    'science': 'Sci-Fi',
    'space': 'Sci-Fi',
    'alien': 'Sci-Fi',
    'comedy': 'Comedy',
    'funny': 'Comedy',
    'drama': 'Drama',
    'documentary': 'Documentary',
    'history': 'History',
    'biography': 'Documentary',
    'music': 'Music',
    'concert': 'Music',
    'horror': 'Horror',
    'thriller': 'Thriller',
    'adventure': 'Adventure',
    'fantasy': 'Fantasy',
    'superhero': 'Action',
    'action': 'Action'
}
</div></code></pre>
<p>then defined a function to assign genres using numpy</p>
<pre class="hljs"><code><div>import numpy as np

def infer_genre_from_title(title): # defining a function
    if pd.isna(title): # if there is any missing row in title, so return &quot;none&quot;
        return None
    title_lower = title.lower() # convert entries of title in lower case
    for keyword, genre in keyword_genre_map.items(): # Loops through every keyword → genre pair in your keyword_genre_map dictionary.
        if keyword in title_lower: # if keyword is present then rturn genre
            return genre
    return None  # If no keyword matches
</div></code></pre>
<p>then i filled the missing genres using function</p>
<pre class="hljs"><code><div># Fill missing genres based on title

df['genres'] = np.where(
    df['genres'].isna(), # where genre is missing
    df['title'].apply(infer_genre_from_title), # apply the function on title 
    df['genres'] # and fill genres where it is missing
)

# If some still remain missing, fill them as &quot;Unknown&quot;

df['genres'] = df['genres'].fillna(&quot;Unknown&quot;)
</div></code></pre>
<ol start="2">
<li>
<p>Dealing with Outliers:</p>
<h4 id="boxplot-of-popularity">Boxplot of Popularity:</h4>
</li>
</ol>
<p><img src="popularity_boxplot.png" alt="boxplot_popularity"></p>
<h4 id="boxplot-of-votecount">Boxplot of vote_count:</h4>
<p><img src="vote_count_boxplot.png" alt="vote_count_boxplot"></p>
<p>The Boxplots of Popularity and Vote_count are showing that they have some outliers.</p>
<p>I have come to the point that these high values are not the outliers but the real values of data (Real data of Netflix shows).
They should not be removed.
We can scaled the values to take insights from them by comparision methods.</p>
<ol start="3">
<li>
<p>Normalization/Scaling:</p>
<p>The values of popularity and vote_counts are very high and very low. That is why the distribution is not normal but long tailed and right skewed.</p>
<p>I applied the Log Transformation on Popularity and Vote_count.</p>
</li>
</ol>
<h4 id="popularity-distribution">Popularity Distribution:</h4>
<p><img src="pop_dist.png" alt="pop_dist"></p>
<h4 id="votecount-distribution">Vote_count Distribution:</h4>
<p><img src="vote_count_dist.png" alt="vote_count_dist"></p>
<h4 id="rating-distribution">Rating Distribution:</h4>
<p><img src="rating_dist.png" alt="rating_dist"></p>
<p>These plots are showing distribution after applying Log transformation</p>
<p>I applied LOG on popularity.</p>
<pre class="hljs"><code><div># Normalizing the popularity using log transformation

df['popularity'] = np.log(df['popularity'])

df.head()
</div></code></pre>
<p>I applied Log1p on popularity because the original values of vote_count are smaller.</p>
<pre class="hljs"><code><div># Normalizing the popularity using log transformation

df['vote_count'] = np.log1p(df['vote_count'])

df.head()
</div></code></pre>
<h3 id="findings">Findings:</h3>
<h4 id="1-i-grouped-top-10-genres-in-terms-of-average-rating">1: I grouped top 10 genres in terms of Average rating.</h4>
<h4 id="the-barplot-of-average-rating-of-top-10-genres">The Barplot of Average rating of top 10 genres:</h4>
<p><img src="Rating.png" alt="Rating"></p>
<p>The Barplot is showing that the netflix shows whose genres are Crime, Drama is the genre that has highest ratings in 2025.</p>
<pre class="hljs"><code><div>import plotly.express as px

# First, group and aggregate (Plotly needs summarized data for bar charts)

top_genres = df['genres'].value_counts().index[:10]
df_top = df[df['genres'].isin(top_genres)]

df_grouped = df_top.groupby('genres', as_index=False)['rating'].mean()

# Sort genres by mean vote_average for consistent order

df_grouped = df_grouped.sort_values('rating', ascending=False)

# Create bar plot

fig = px.bar(
    df_grouped,
    x='genres',
    y='rating',
    text='rating',  # Add labels on bars
    title='Average Rating by Top 10 Genres',
)

# Format labels and layout

fig.update_traces(
    texttemplate='%{text:.2f}',  # Format to 2 decimal places
    textposition='outside'
)

fig.update_layout(
    xaxis_title=&quot;Genres&quot;,
    yaxis_title=&quot;rating&quot;,
    xaxis={'categoryorder':'total descending'},
    plot_bgcolor='white',
    title_x=0.5,
    width=900,
    height=500
)

fig.show()

</div></code></pre>
<h4 id="2-i-grouped-top-10-genres-in-terms-of-average-popularity">2: I grouped top 10 genres in terms of Average Popularity.</h4>
<h4 id="the-barplot-of-average-popularity-of-top-10-genres">The Barplot of Average popularity of top 10 genres:</h4>
<p><img src="popularity.png" alt="popularity"></p>
<p>The Barplot is showing that the netflix shows whose genres are Crime, Drama is the genre that has highest popularity in 2025.</p>
<pre class="hljs"><code><div>import plotly.express as px

# First, group and aggregate (Plotly needs summarized data for bar charts)

top_genres = df['genres'].value_counts().index[:10]
df_top = df[df['genres'].isin(top_genres)]

df_grouped = df_top.groupby('genres', as_index=False)['popularity'].mean()

# Sort genres by mean vote_average for consistent order

df_grouped = df_grouped.sort_values('popularity', ascending=False)

# Create bar plot

fig = px.bar(
    df_grouped,
    x='genres',
    y='popularity',
    text='popularity',  # Add labels on bars
    title='Average Popularity by Top 10 Genres',
)

# Format labels and layout

fig.update_traces(
    texttemplate='%{text:.2f}',  # Format to 2 decimal places
    textposition='outside'
)

fig.update_layout(
    xaxis_title=&quot;Genres&quot;,
    yaxis_title=&quot;Popularity&quot;,
    xaxis={'categoryorder':'total descending'},
    plot_bgcolor='white',
    title_x=0.5,
    width=900,
    height=500
)

fig.show()
</div></code></pre>
<h4 id="3-i-grouped-top-10-genres-in-terms-of-voteaverage">3: I grouped top 10 genres in terms of vote_average.</h4>
<h4 id="the-barplot-of-voteaverage-of-top-10-genres">The Barplot of vote_average of top 10 genres:</h4>
<p><img src="VoteAverage.png" alt="VoteAverage"></p>
<p>The Barplot is showing that the netflix shows whose genres are Crime, Drama is the genre that has highest vote_average in 2025.</p>
<pre class="hljs"><code><div>import plotly.express as px

# First, group and aggregate (Plotly needs summarized data for bar charts)

top_genres = df['genres'].value_counts().index[:10]
df_top = df[df['genres'].isin(top_genres)]

df_grouped = df_top.groupby('genres', as_index=False)['vote_average'].mean()

# Sort genres by mean vote_average for consistent order

df_grouped = df_grouped.sort_values('vote_average', ascending=False)

# Create bar plot

fig = px.bar(
    df_grouped,
    x='genres',
    y='vote_average',
    text='vote_average',  # Add labels on bars
    title='Average Vote by Top 10 Genres',
)

# Format labels and layout

fig.update_traces(
    texttemplate='%{text:.2f}',  # Format to 2 decimal places
    textposition='outside'
)

fig.update_layout(
    xaxis_title=&quot;Genres&quot;,
    yaxis_title=&quot;Average Vote&quot;,
    xaxis={'categoryorder':'total descending'},
    plot_bgcolor='white',
    title_x=0.5,
    width=900,
    height=500
)

fig.show()
</div></code></pre>
<h3 id="conclusion">Conclusion:</h3>
<p>Drama and Crime are the leading Netflix genres of 2025, outperforming all others in terms of ratings, popularity, and audience engagement.
This suggests that Netflix users have a strong preference for emotionally engaging, suspenseful storytelling and character-driven narratives.</p>

</body>
</html>
